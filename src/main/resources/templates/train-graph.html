<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Train Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
</head>

<body>
    <div class="chart-container" style="position: relative; height:100vh; width:95vw">
        <canvas id="trainGraph"></canvas>
    </div>

    <script>
        function fillNullValues(arr) {
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] === null) {
                    var start = i - 1;
                    while (arr[i] === null) {
                        i++;
                    }
                    var end = i;
                    var startValue = arr[start];
                    var endValue = arr[end];
                    var diff = (endValue - startValue) / (end - start);

                    for (var j = start + 1; j < end; j++) {
                        arr[j] = startValue + diff * (j - start);
                    }
                }
            }

            return arr;
        }


        var ctx = document.getElementById("trainGraph").getContext("2d");


        function renderChart() {
            var stationNames = [
                "Helsinki asema",
                "Pasila asema",
                "Ilmala asema",
                "Helsinki Kivihaka",
                "Huopalahti",
                "Valimo",
                "Pitäjänmäki",
                "Mäkkyla",
                "Leppävaara",
            ];

            var distances = [
                0.2, 3.2, 4.4, 4.7, 6.4, 7.5, 8.5, 9.5, 11.2
            ];

            // Calculate the time range
            var currentTime = new Date();
            var startTime = new Date(currentTime.getTime() - 30 * 60 * 1000); // 30 minutes before current time
            var endTime = new Date(currentTime.getTime() + 30 * 60 * 1000); // 30 minutes after current time
            var interval = 1 * 60 * 1000; // 60 second in milliseconds
            // var interval = 1000; // 1 second in milliseconds

            var timeLabels = [];
            for (var time = startTime; time <= endTime; time = new Date(time.getTime() + interval)) {
                var hours = time.getHours().toString().padStart(2, '0');
                var minutes = time.getMinutes().toString().padStart(2, '0');
                var formattedTime = hours + ':' + minutes;
                timeLabels.push(formattedTime);
            }

            // Destroy the existing Chart instance if it exists
            // if (chart) {
            //     chart.destroy();
            // }

            const totalDuration = timeLabels.length;
            const delayBetweenPoints = 30;
            const previousY = 0;
            const animation = {
                x: {
                    type: 'number',
                    easing: 'linear',
                    duration: delayBetweenPoints,
                    from: NaN, // the point is initially skipped
                    delay(ctx) {
                        if (ctx.type !== 'data' || ctx.xStarted) {
                            return 0;
                        }
                        ctx.xStarted = true;
                        return ctx.index * delayBetweenPoints;
                    }
                },
                y: {
                    type: 'number',
                    easing: 'linear',
                    duration: delayBetweenPoints,
                    from: previousY,
                    delay(ctx) {
                        if (ctx.type !== 'data' || ctx.yStarted) {
                            return 0;
                        }
                        ctx.yStarted = true;
                        return ctx.index * delayBetweenPoints;
                    }
                }
            };


            const chartData = {
                plugins: [ChartDataLabels],
                type: "line",
                data: {
                    labels: timeLabels, //x axis
                    datasets: []
                },
                options: {
                    hover: {
                        mode: 'dataset',
                        intersect: false
                    },
                    onHover: function (context, values) {
                        var datasetIndex = values[0].datasetIndex;
                        var dataset = context.chart.data.datasets;
                        var currentLabel = dataset[datasetIndex].label;

                        dataset.forEach(function (element) {
                            if (element.label === currentLabel) {
                                element.borderWidth = element.hoverBorderWidth; // Increase border width for matching datasets
                            } else {
                                element.borderWidth = Math.floor(element.hoverBorderWidth / 2); // Reset border width for non-matching datasets
                            }
                        });
                        context.chart.update('none'); // Update the chart to apply the changes
                    },
                    // animation,
                    showDatasetLabels: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function (context) {
                                    return "Train number: " + context[0].dataset.label;
                                },
                                label: function (context) {
                                    var time = "Time: " + context.label;
                                    var val = "Distance: " + context.formattedValue;
                                    return time + "\n" + val
                                }
                            }
                        },
                        annotation: {
                            annotations: [
                                {
                                    type: 'line',
                                    xMin: 30,
                                    xMax: 30,
                                    borderColor: '#00BB00',
                                    borderWidth: 2,
                                },
                            ]
                        },
                        datalabels: {
                            display: function (context) {
                                // Hide data labels for all data points except the middle one
                                return context.dataIndex === Math.floor(context.dataset.data.length / 2);
                            },
                            color: 'blue',
                            font: {
                                weight: 'bold',
                                size: 12
                            },
                            textAlign: 'end',
                            textBaseline: 'middle',
                            formatter: function (value, context) {
                                // Show label only for the middle data point
                                if (context.dataIndex === Math.floor(context.dataset.data.length / 2)) {
                                    return context.dataset.label;
                                }
                                return null;
                            },
                            align: 'start',
                            anchor: 'center',
                            padding: {
                                top: 2,
                                right: 2,
                                bottom: 2,
                                left: 2
                            },
                            backgroundColor: 'white',
                            borderRadius: 4,
                            borderWidth: 1,
                            // borderColor: 'black',
                            anchor: 'end',
                            align: 'end',
                            offset: 4
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: true,
                            },
                            display: true,
                            title: {
                                // display: true,
                                text: "Time"
                            },
                            ticks: {
                                callback: function (value, index, values) {
                                    // Show label only for every 10th value
                                    if (index % 10 === 0) {
                                        return timeLabels[index];
                                    }
                                    return null;
                                },
                                maxRotation: 0, // Prevent rotation
                                minRotation: 0,  // Prevent rotation
                                stepSize: 0.1,
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                // display: true,
                                text: "Distance (km)"
                            },
                            min: 0.2,
                            max: 11.2,
                            ticks: {
                                callback: function (value, index, values) {
                                    if (distances.includes(value)) {
                                        var distanceIndex = distances.indexOf(value);
                                        return stationNames[distanceIndex] + " (" + value + " km)";
                                    }
                                    return null;
                                },
                                stepSize: 0.1, // Set the desired step size for the y-axis
                            }
                        }
                    }
                }
            };

            return chartData;
        }

        // Render the initial chart
        var chartData = renderChart();
        var chart = new Chart(ctx, chartData);

        function updateChart() {
            // Make an API call using fetch()
            fetch('http://localhost:8080/live-trains')
                .then(response => response.json())
                .then(data => {
                    // Process the data returned by the API
                    console.log(data);
                    if (data.length == 0) {
                        return
                    }
                    data.forEach(trainData => {
                        const scheduledData = {
                            label: trainData.trainNumber,
                            data: fillNullValues(trainData.scheduledTimes),
                            borderColor: trainData.trainColor,
                            borderWidth: 1,
                            // animation: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            hoverBorderWidth: 3,
                            originalBorderWidth: 1,
                            datalabels: {
                                display: false,
                            }
                        };
                        const actualData = {
                            label: trainData.trainNumber,
                            data: fillNullValues(trainData.actualTimes),
                            borderColor: trainData.trainColor,
                            borderWidth: 2,
                            // animation: true,
                            pointRadius: 2,
                            pointHoverRadius: 2,
                            hoverBorderWidth: 4,
                            originalBorderWidth: 2,
                            hoverBorderColor: 'black', // Set the border color on hover
                            datalabels: {
                                display: true,
                            }
                        };
                        chart.data.datasets.forEach((dataset) => {
                            dataset.data.pop();
                        });
                        chart.data.datasets.push(scheduledData);
                        chart.data.datasets.push(actualData);
                        chart.update('none');
                    });
                })
                .catch(error => {
                    // Handle any errors that occurred during the API call
                    console.error('Error:', error);
                });
            console.log("hello");
        }
        updateChart();
        // Reload the chart every 1 minute
        setInterval(updateChart, 60000); // 60000 milliseconds = 1 minute

        // Reset borderWidth values when mouse is outside the canvas
        var canvas = document.getElementById("trainGraph");
        canvas.addEventListener('mouseout', function (event) {
            var dataset = chart.data.datasets;

            dataset.forEach(function (element) {
                element.borderWidth = element.originalBorderWidth; // Reset borderWidth to the original value
            });

            chart.update('none'); // Update the chart to apply the changes
        });
    </script>
</body>

</html>